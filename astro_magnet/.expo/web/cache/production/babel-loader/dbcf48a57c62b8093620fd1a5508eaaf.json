{"ast":null,"code":"import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import{CodedError}from'expo-modules-core';var GOOGLE_API_URL='https://maps.googleapis.com/maps/api/geocode/json';var googleApiKey;export function setGoogleApiKey(apiKey){googleApiKey=apiKey;}export function googleGeocodeAsync(_x){return _googleGeocodeAsync.apply(this,arguments);}function _googleGeocodeAsync(){_googleGeocodeAsync=_asyncToGenerator(function*(address){assertGoogleApiKey();var result=yield requestGoogleApiAsync({address:address});if(result.status==='ZERO_RESULTS'){return[];}assertGeocodeResults(result);return result.results.map(geocodingResultToLocation);});return _googleGeocodeAsync.apply(this,arguments);}export function googleReverseGeocodeAsync(_x2){return _googleReverseGeocodeAsync.apply(this,arguments);}function _googleReverseGeocodeAsync(){_googleReverseGeocodeAsync=_asyncToGenerator(function*(options){assertGoogleApiKey();var result=yield requestGoogleApiAsync({latlng:options.latitude+\",\"+options.longitude});if(result.status==='ZERO_RESULTS'){return[];}assertGeocodeResults(result);return result.results.map(reverseGeocodingResultToAddress);});return _googleReverseGeocodeAsync.apply(this,arguments);}function assertGeocodeResults(resultObject){var status=resultObject.status,error_message=resultObject.error_message;if(status!=='ZERO_RESULTS'&&status!=='OK'){if(error_message){throw new CodedError(status,error_message);}else if(status==='UNKNOWN_ERROR'){throw new CodedError(status,'the request could not be processed due to a server error. The request may succeed if you try again.');}throw new CodedError(status,\"An error occurred during geocoding.\");}}function assertGoogleApiKey(){if(!googleApiKey){throw new Error('Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.');}}function requestGoogleApiAsync(_x3){return _requestGoogleApiAsync.apply(this,arguments);}function _requestGoogleApiAsync(){_requestGoogleApiAsync=_asyncToGenerator(function*(params){var query=Object.entries(params).map(function(entry){return entry[0]+\"=\"+encodeURI(entry[1]);}).join('&');var result=yield fetch(GOOGLE_API_URL+\"?key=\"+googleApiKey+\"&\"+query);return yield result.json();});return _requestGoogleApiAsync.apply(this,arguments);}function geocodingResultToLocation(result){var location=result.geometry.location;return{latitude:location.lat,longitude:location.lng};}function reverseGeocodingResultToAddress(result){var address={};for(var _ref of result.address_components){var long_name=_ref.long_name;var short_name=_ref.short_name;var types=_ref.types;if(types.includes('locality')){address.city=long_name;continue;}if(types.includes('sublocality')){address.district=long_name;continue;}if(types.includes('street_number')){address.streetNumber=long_name;continue;}if(types.includes('street_address')||types.includes('route')){address.street=long_name;continue;}if(types.includes('administrative_area_level_1')){address.region=long_name;continue;}if(types.includes('administrative_area_level_2')){address.subregion=long_name;continue;}if(types.includes('country')){address.country=long_name;address.isoCountryCode=short_name;continue;}if(types.includes('postal_code')){address.postalCode=long_name;continue;}if(types.includes('point_of_interest')){address.name=long_name;continue;}}if(!address.name){address.name=result.formatted_address.replace(/,.*$/,'');}return address;}","map":{"version":3,"sources":["../src/LocationGoogleGeocoding.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodedError } from 'expo-modules-core';\n\nimport { LocationGeocodedAddress, LocationGeocodedLocation } from './Location.types';\n\nconst GOOGLE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';\nlet googleApiKey;\n\ntype GoogleApiGeocodingAddressComponent = {\n  long_name: string;\n  short_name: string;\n  types: string[];\n};\n\ntype GoogleApiGeocodingResult = {\n  address_components: GoogleApiGeocodingAddressComponent[];\n  formatted_address: string;\n  geometry: {\n    location: {\n      lat: number;\n      lng: number;\n    };\n  };\n};\n\ntype GoogleApiGeocodingResponse = {\n  results: GoogleApiGeocodingResult[];\n  status: string;\n};\n\n// @needsAudit\n/**\n * Sets a Google API Key for using Google Maps Geocoding API which is used by default on Web\n * platform and can be enabled through `useGoogleMaps` option of `geocodeAsync` and `reverseGeocodeAsync`\n * methods. It might be useful for Android devices that do not have Google Play Services, hence no\n * Geocoder Service.\n * @param apiKey Google API key obtained from Google API Console. This API key must have `Geocoding API`\n * enabled, otherwise your geocoding requests will be denied.\n */\nexport function setGoogleApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nexport async function googleGeocodeAsync(address: string): Promise<LocationGeocodedLocation[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({ address });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(geocodingResultToLocation);\n}\n\nexport async function googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<LocationGeocodedAddress[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({\n    latlng: `${options.latitude},${options.longitude}`,\n  });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(reverseGeocodingResultToAddress);\n}\n\n// https://developers.google.com/maps/documentation/geocoding/intro\nfunction assertGeocodeResults(resultObject: any): void {\n  const { status, error_message } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(\n        status,\n        'the request could not be processed due to a server error. The request may succeed if you try again.'\n      );\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\n\n/**\n * Makes sure the Google API key is set.\n */\nfunction assertGoogleApiKey() {\n  if (!googleApiKey) {\n    throw new Error(\n      'Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.'\n    );\n  }\n}\n\n/**\n * Generic and handy method for sending requests to Google Maps API endpoint.\n */\nasync function requestGoogleApiAsync(\n  params: { address: string } | { latlng: string }\n): Promise<GoogleApiGeocodingResponse> {\n  const query = Object.entries(params)\n    .map((entry) => `${entry[0]}=${encodeURI(entry[1])}`)\n    .join('&');\n  const result = await fetch(`${GOOGLE_API_URL}?key=${googleApiKey}&${query}`);\n  return await result.json();\n}\n\n/**\n * Converts Google's result to the location object.\n */\nfunction geocodingResultToLocation(result: GoogleApiGeocodingResult): LocationGeocodedLocation {\n  const { location } = result.geometry;\n  return {\n    latitude: location.lat,\n    longitude: location.lng,\n  };\n}\n\n/**\n * Converts Google's result to address object.\n */\nfunction reverseGeocodingResultToAddress(\n  result: GoogleApiGeocodingResult\n): LocationGeocodedAddress {\n  const address: Partial<LocationGeocodedAddress> = {};\n\n  for (const { long_name, short_name, types } of result.address_components) {\n    if (types.includes('locality')) {\n      address.city = long_name;\n      continue;\n    }\n    if (types.includes('sublocality')) {\n      address.district = long_name;\n      continue;\n    }\n    if (types.includes('street_number')) {\n      address.streetNumber = long_name;\n      continue;\n    }\n    if (types.includes('street_address') || types.includes('route')) {\n      address.street = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_1')) {\n      address.region = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_2')) {\n      address.subregion = long_name;\n      continue;\n    }\n    if (types.includes('country')) {\n      address.country = long_name;\n      address.isoCountryCode = short_name;\n      continue;\n    }\n    if (types.includes('postal_code')) {\n      address.postalCode = long_name;\n      continue;\n    }\n    if (types.includes('point_of_interest')) {\n      address.name = long_name;\n      continue;\n    }\n  }\n  if (!address.name) {\n    address.name = result.formatted_address.replace(/,.*$/, '');\n  }\n  return address as LocationGeocodedAddress;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}